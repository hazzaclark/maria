// COPYRIGHT (C) HARRY CLARK 2025
// LIGHTWEIGHT CODE EMITTER/GENERATOR FOR THE HITACHI SUPERH2

// THIS FILE PERTAINS TOWARDS THE MAIN FUNCTIONALITY ENCOMPASSING THE ACTUAL EMITTER
// THROUGH THIS, I WILL LEVERAGE A ALLOCATABLE BUFFER WHICH PRESUPPOSES THE CURRENT STRUCTURE
// ENCOMPASSING THE INSTRUCTIONS 

// THIS WILL ALSO PRESUPPOSE ANY AND ALL ARBITRARY MEMORY INCLUDED WITHIN THE BUFFER
// SO, THE BUFFER WILL BE ABLE TO DYNAMICALLY GROW AND EMIT ACCORDINGLY

// NESTED INCLUDES

#include <impl/buffer.hh>

// SYSTEM INCLUDES

#include <cstring>
#include <utility>

namespace maria
{
    // SELF ENCAPSULATED MEMORY FLAGS FOR RUNTIME 
    BUFFER::BUFFER(UNK CAPACITY)
        :_CAPACITY(CAPACITY), _MANAGE{true} 
        { 
            if(CAPACITY == 0) return;
            
            // TO BE A *bit more* POSIX COMPLIANT, WE WILL JUST PRESUPPOSE
            // A RAW DEFINED MEMORY BUFFER WITHIN THE CURRENT CIRCUMSTANCE

            _BUFFER = new U8[CAPACITY]();
            _CURSOR = _BUFFER; 
        }

    
    // NOW WE WILL ACTUALLY CREATE A CONSTRUCTOR
    // THAT ENCOMPASSES THE MAIN BUFFER
    BUFFER::BUFFER(U8* BUFFER, UNK CAPACITY)
        : _BUFFER{BUFFER}, _CURSOR{BUFFER}, _CAPACITY{CAPACITY}
        {
            assert(BUFFER != nullptr);
        }

    // DEFINE THE MOVE CONSTRUCTOR
    // THROUGH THIS, WE WILL BE ABLE TO DYNAMICALLY ACCESS CORRESPONDENCE FROM
    // THE ABOVE CONSTRUCTORS WITHOUT REDEFINING, GREAT FOR ACCESSING MEMORY

    // THIS IS DONE BY ACCESSING THE CURRENT VALUE AND RETURNING IT
    // IN RELATION TO THE PREVIOUS, ALLOWING FOR EASE OF USE MOVING

    BUFFER::BUFFER(BUFFER&& BUFFER_MOVE) noexcept
        :_BUFFER{std::exchange(BUFFER_MOVE._BUFFER, nullptr)}
        , _CURSOR{std::exchange(BUFFER_MOVE._CURSOR, nullptr)}
        , _CAPACITY{std::exchange(BUFFER_MOVE._CAPACITY, UNK{0})}
        , _MANAGE{std::exchange(BUFFER_MOVE._MANAGE, false)} {}
}
