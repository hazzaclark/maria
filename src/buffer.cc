// COPYRIGHT (C) HARRY CLARK 2025
// LIGHTWEIGHT CODE EMITTER/GENERATOR FOR THE HITACHI SUPERH2

// THIS FILE PERTAINS TOWARDS THE MAIN FUNCTIONALITY ENCOMPASSING THE ACTUAL EMITTER
// THROUGH THIS, I WILL LEVERAGE A ALLOCATABLE BUFFER WHICH PRESUPPOSES THE CURRENT STRUCTURE
// ENCOMPASSING THE INSTRUCTIONS 

// THIS WILL ALSO PRESUPPOSE ANY AND ALL ARBITRARY MEMORY INCLUDED WITHIN THE BUFFER
// SO, THE BUFFER WILL BE ABLE TO DYNAMICALLY GROW AND EMIT ACCORDINGLY

// NESTED INCLUDES

#include <impl/buffer.hh>

// SYSTEM INCLUDES

#include <algorithm>
#include <cstring>
#include <cassert>
#include <memory>
#include <utility>
#include <vector>

namespace maria
{
    // SELF ENCAPSULATED MEMORY FLAGS FOR RUNTIME 
    BUFFER::BUFFER(size_t CAPACITY) :_CAPACITY(CAPACITY), _MANAGE{true} 
    { 
        if(CAPACITY == 0) return;
            
        // TO BE A *bit more* POSIX COMPLIANT, WE WILL JUST PRESUPPOSE
        // A RAW DEFINED MEMORY BUFFER WITHIN THE CURRENT CIRCUMSTANCE

        _BUFFER = new U8[CAPACITY]();
        _CURSOR = _BUFFER; 
    }

    
    // NOW WE WILL ACTUALLY CREATE A CONSTRUCTOR
    // THAT ENCOMPASSES THE MAIN BUFFER
    BUFFER::BUFFER(U8* BUFFER, size_t CAPACITY) : _BUFFER{BUFFER}, _CURSOR{BUFFER}, _CAPACITY{CAPACITY}
    {
        assert(BUFFER != nullptr);
    }

    // DEFINE THE MOVE CONSTRUCTOR
    // THROUGH THIS, WE WILL BE ABLE TO DYNAMICALLY ACCESS CORRESPONDENCE FROM
    // THE ABOVE CONSTRUCTORS WITHOUT REDEFINING, GREAT FOR ACCESSING MEMORY

    // THIS IS DONE BY ACCESSING THE CURRENT VALUE AND RETURNING IT
    // IN RELATION TO THE PREVIOUS, ALLOWING FOR EASE OF USE MOVING

    BUFFER::BUFFER(BUFFER&& BUFFER_MOVE) noexcept
        :_BUFFER{std::exchange(BUFFER_MOVE._BUFFER, nullptr)}
        , _CURSOR{std::exchange(BUFFER_MOVE._CURSOR, nullptr)}
        , _CAPACITY{std::exchange(BUFFER_MOVE._CAPACITY, size_t{0})}
        , _MANAGE{std::exchange(BUFFER_MOVE._MANAGE, false)} {}


    BUFFER::~BUFFER() noexcept
    {
        if(!_MANAGE) { return; }

        delete[] _BUFFER;
    }

    // DYNAMICALLY ASSERT THE SIZE OF THE MANAGED MEMORY BUFFER AT THE CURRENT MOMENT
    // THIS WAY, WE WILL BE ABLE TO SCALE THE BUFFER ACCORDINGLY TO FIT THE SIZE
    // OF THE CONCURRENT OPERANDS AND ANY OTHER PRE-REQ'S

    void BUFFER::SH2_STACK_GROW(size_t NEW_CAPACITY)
    {
        assert(SH2_MANAGED());

        // SHOULD WE EVER ENCOUNTER A NOP, DO NOTHING
        // THAT WAY, THE STACK WILL BE STILL SCALE WITHOUT INTERFERENCE

        if(NEW_CAPACITY <= _CAPACITY) return;

        // ANY AND ALL INFO WE ENCOUNTER, ADD TO THE BUFFER
        // AND SCALE UP BASED ON THE NEW CAPACITY

        auto SH2_NEW_BUFFER = std::make_unique<U8[]>(NEW_CAPACITY);

        // CURRENT SIZE FOR CURSOR POSTION RELATED TO BUFFER
        size_t CURRENT_SIZE = _CURSOR - _BUFFER;

        // COPY OLD DATA INTO THE NEW IF IT EXISTS

        if(_BUFFER && CURRENT_SIZE > 0)
        {
            std::copy(_BUFFER, _BUFFER + CURRENT_SIZE, SH2_NEW_BUFFER.get());
        }

        if(_MANAGE && _BUFFER) delete[] _BUFFER;

        // UPDATE THE CORRESPONDENCE FOR THE BUFFER AND RELEVANT CAPACITY
        _BUFFER = SH2_NEW_BUFFER.release();
        _CURSOR = _BUFFER + CURRENT_SIZE;
        _CAPACITY = NEW_CAPACITY;
        _MANAGE = true;
    }
}
